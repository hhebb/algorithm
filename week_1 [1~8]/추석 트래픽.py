'''
* 문제 유형
    단순 구현
    약간 까다로움

* 체감 난이도
    ***

* 풀이
    1. 자료 재구성
        시간의 단위가 여러 개 라서 가장 작은 ms 단위로 통일시켜서 계산.
        로그의 시작과 종료 시각을 한 쌍의 tuple 형태로 차례대로 저장.
    2. 구간 데이터 counting
        log 기록 수 만큼 루프를 2 중으로 돌면서 각 구간(1초 동안) 에 포함된 로그 기록들을 센다.
        각 로그 기록들의 종료직전 시각에서 1 초 동안 겹치는 모든 로그들을 카운팅한다.

* 주의할 점
    문제에서 '처리 시간'은 로그의 시작 시간이 포함된다고 했으므로 시작 시간을 구할 땐 0.001 초 더해줘야 함.
    문제에서 말하는 초당 최대 처리량에 해당하는 '구간' 을 잘 지정할 수 있어야 함.


* 문법 팁
    다들 알고 계실수도 있지만
    입력 데이터를 'split' 함수를 이용해 쪼갬
    파이썬은 비교 연산자를 연속으로 사용할 수 있다. if 1 < 2 < 3:


* 결과
    테스트 1 〉	통과 (0.05ms, 10.3MB)
    테스트 2 〉	통과 (57.18ms, 10.6MB)
    테스트 3 〉	통과 (69.53ms, 10.4MB)
    테스트 4 〉	통과 (0.02ms, 10.3MB)
    테스트 5 〉	통과 (0.90ms, 10.3MB)
    테스트 6 〉	통과 (0.92ms, 10.2MB)
    테스트 7 〉	통과 (57.03ms, 10.5MB)
    테스트 8 〉	통과 (59.28ms, 10.4MB)
    테스트 9 〉	통과 (0.73ms, 10.3MB)
    테스트 10 〉	통과 (0.04ms, 10.1MB)
    테스트 11 〉	통과 (0.05ms, 10.3MB)
    테스트 12 〉	통과 (56.74ms, 10.4MB)
    테스트 13 〉	통과 (0.89ms, 10.2MB)
    테스트 14 〉	통과 (0.03ms, 10.3MB)
    테스트 15 〉	통과 (0.04ms, 10.4MB)
    테스트 16 〉	통과 (0.02ms, 10.2MB)
    테스트 17 〉	통과 (0.04ms, 10.3MB)
    테스트 18 〉	통과 (310.22ms, 10.4MB)
    테스트 19 〉	통과 (231.32ms, 10.6MB)
    테스트 20 〉	통과 (249.11ms, 10.4MB)
    테스트 21 〉	통과 (0.02ms, 10.3MB)
    테스트 22 〉	통과 (0.02ms, 10.2MB)
'''


def solution(lines):
    record = [] # 입력으로 주어진 데이터를 계산하기 좋게 변환한 데이터
    for line in lines:
        date, time, duration = line.split(' ')
        hour, minute, sec = time.split(':')
        sec, ms = sec.split('.')
        duration = float(duration[:-1]) * 1000
        segment = int(hour) * 3600000 + int(minute) * 60000 + int(sec) * 1000
        total = segment + int(ms)
        record.append((int(total - duration + 1), total)) # 처리 시간이 끝시간을 포함하므로 시작 시간을 0.001 초 더해야 함!

    # print(record)

    traffics = []
    for s, e in record: # 모든 기록들에 대해 검사 -- 로그 기록 (1)
        tmp = 0
        for s1, e1 in record: # (2)
            # 로그 기록 (1) 이 종료되기 직전 시점에서부터 이후 1 초 동안 로그 기록이 존재하는 모든 케이스 카운팅.
            # 이러면 로그 기록 (1) 이 항상 끄트머리에 포함된다.
            # (1) 과 (2) 가 구간내에 겹치는 지 판단.
            if s1-999 <= e <= e1:
                tmp += 1
        traffics.append(tmp)
        # print((s1, e1), tmp)
    return max(traffics)